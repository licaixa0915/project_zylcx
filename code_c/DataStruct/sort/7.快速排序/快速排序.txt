<1>简介
快速排序是编程中经常使用到的一种排序方法。可是很多朋友对快速排序有畏难情绪，
认为快速排序使用到了递归，是一种非常复杂的程序，其实未必如此。
只要我们使用好了方法，就可以自己实现快速排序。我们的快速排序采用了分治法的想法。

<2>思路
例如：int array[] = {12,2,34,100,23,56,8,45};
(1)先从数组中选取一个数作为基准数，用key来表示。（通常选取数组的第一个元素）
(2)开始分的过程，一般是定义两个变量i和j，分别表示第一个元素和最后一个元素
	 的下标。
	 我们将比key小的值全部存放到key的左边，将比keyda的值全部存储到key的右边。
	 (具体思路：
	 i												 j			key = 12;    
	 12  2  34  100 23  56  8 45
	 我们先偏移a[j]，若是发现a[j] < key，则把a[i] = a[j],否则j--.(小的放左边)
	 然后偏移a[i],   若是发现a[i] > key,则把a[i] = a[j],否则i++.(大的放右边)
	 当i >= j的时候，一轮比较停止,并把此时a[i] = key。
	 一轮比较完毕之后，结果如下：
	 [ 8 2 ] 12 [ 100 23 56 34 45 ]
	 
	 第二轮比较结果：
	   2 8   12   [45  23 56 34] 100
	 第三轮比较结果：
	   2 8   12   [34 23] 45 56  100
	 第四轮比较结果：
	 	 2 8   12    23 34  45 56  100
	 )
	 
(3)重复第二个步骤，知道每个区间只剩一个数为止（递归的思想）

代码详解：
int a[] = {12,2,34,100,23,56,8,45};
int low = 0; //第一个元素的下标
int high = sizeof(a)/sizeof(a[0]) - 1;//最后一个元素的下标

quick_sort(a,low,high);

void quick_sort(int a[],int low,int high)
{
		int i = 0,j = 0,key = 0;
		i = low;
		j = high;
		key = a[low];

		while(i < j)
		{
				//从j开始，找到比key小的
				//放到i的位置
				while(i < j && a[j] >= key)	
						j--;
						
				if(i < j)
				{
						a[i] = a[j];	
				}
				//从i开始,找到比key大的位置
				//放到j的位置
				while(i < j && a[i] <= key)
					i++;
					
				if(i < j)
				{
						a[j] = a[i];	
				}	
		}
		
		//循环结束后，a[i]的值没有变，
		//把key值放入
		a[i] = key;
		
		//若是我们没有遍历到第一个元素的下标
		if(j - 1 >low)
		{
				//继续遍历,区间为[0,j-1]
				quick_sort(a,low,j - 1);	
		}
		
		//若是我们没有遍历到最后一个元素的下标
		if(j - 1 >low)
		{
				//继续遍历,区间为[i + 1,high]
				quick_sort(a,i + 1,high);	
		}
		return;
}

