例如：int a[5] = {5,4,3,2,1};

选择排序的思想。（从小到大排列）
首先，定义一个值k，表示最小值得下标。假设第一个数是最小的，
把第一个数据的下标赋值给k = 0，然后依次让后面的数据和a[k]相比，比它数据小的，
就让k和比它小的数据交换位置。后面依次如此，比较完毕后，
判断数据的值是否改变。若是改变了。把k的值与a[0]交换。则第一个数是最小的。

然后a[k] 与a[1]比较数据。以此类推。最后得到从小到大的数据。

比如说有5个数字  5,4,3,2,1
定义一个k = 0；
首先k 指向第一个元素;
	 

<1>i = 0;i < 5;j < 5
	 k = 0, 
	 j = 1; a[0] > a[1],成立，k = j = 1;
	 j = 2; a[1] > a[2],成立，k = j = 2;
	 j = 3; a[3] > a[2],成立，k = j = 3;
	 j = 4; a[4] > a[1],成立，k = j = 4; 
	 内存循环完成，k = 4，i = 0，k != i,交换a[k]和a[i]的值
	 交换完成后，{1,4,3,2,5}
<2>i = 1;i < 5;j < 5
	  k = 1,
	  j = 2;a[1] > a[2],成立，k = j = 2
	  j = 3;a[2] > a[3],成立，k = j = 3
	  j = 4;a[3] > a[4],不成了
	  内存循环完成，k = 3,i = 1，k！= i,交换a[k]和a[i]的值
	  交换完成后，{1,2,3,4,5}
<3>i = 2;i < 5;j < 5
	 k = 2,
	 j = 3,a[2] > a[3] ,不成立
	 j = 4,a[2] > a[4],不成立
	 内存循环完成，k = 2, i = 2,k == i，不交换a[k]和a[i]的值
	 数组内容依旧为{1,2,3,4,5}

<4>i = 3; i < 5;j < 5
	 k = 3;
	 j = 4, a[3] > a[4] ,不成立

<5>i = 4;i < 5;j < 5
	 k = 4;
	 j = 5; j < 5,不成立，退出内存循环
	 k = 4,i = 4 ,k == i ,不交换a[k]和a[i]的值
	 
	 i++==>i = 5,循环结束。最终a[5] = {1,2,3,4,5}
	 
	 				 第一轮后       第二轮	       第三轮     第四轮	
k -> | 5 |				 | 1 |					| 1 |			 | 1 |        | 1 |
		 | 4 |				 | 4 |					| 2 |		   | 2 |				| 2 |
		 | 3 |-------->| 3 |--------->| 3 |----->| 3 |------->| 3 |
		 | 2 | 				 | 2 |	        | 4 |      | 4 |        | 4 |
		 | 1 |k = 4--> | 5 |	        | 6 |			 | 5 |				| 5 |
												重新让k指向
												 第二个数的下标
		 原始
		 
int a[5] = {5,4,3,2,1}
int i = 0,j = 0,k = 0;
int len = sizeof(a) / sizeof(a[0]);

for(i = 0;i < len;i++)
{
		k = i;  //表示最小元素的下标
		for(j = i + 1;j < len;j++)
		{
				if(a[j] < a[k])
						k = j;
		}
		
		if(i != k)
		{
				a[i] ^= a[k];
				a[k] ^= a[i];
				a[i] ^= a[k];
		}
}		 
i = 0, 内存for循环运行 len - 1次.
i = 1,内存for循环运行len - 2 次
i = len - 2,内存for循环运行1次。

1 + 2 + 3 + ...+ n - 1 = n * (n - 1) / 2 ===>时间复杂度为：O(n^2)