int a[] = {9,1,2,5,7,4,8,6,3,5};

希尔排序思路：希尔排序也是插入排序的一种。他是对直接插入排序的
			 一种版本的改进。我们先将整个待排元素序列分割成
			 若干个子序列(一般元素的个数/2获得)，然后对每个组
			 分别进行直接插入排序。随着序列的逐渐减小，所包含
			 的记录就越来越多，当序列为1的时候，整个数据合成一组。
			 则完成排序。
初始化 
1.gap1 = 10 /2 = 5,相隔距离为5的分成一组，可以分为5组，每列一组，
然后每组直接插入排序。
9 1 2 5 7 
4 8 6 3 5
如上图，我们把它变成列的形式，对每列两个数应用直接插入排序来排列。排序后：
4 1 2 3 5
9 8 6 5 7
========> 4 1 2 3 5 9 8 6 5 7
2.gap2 = 5 /2 = 2，相隔距离为2的分成一组，可以分为 2组。每列一组。
然后每组直接插入排序。
4 1
2 3
5 9 
8 6
5 7
如上图，我们把它变成列的形式，则上列每列数要对应用直接插入排序来排列。排序后：
2 1
4 3
5 6 
5 7
8 9
==========>2 1 4 3 5 6 5 7 8 9
3.gap3 = 2 / 2 = 1,相隔距离为1的分为一组，可以分为1组。直接插入排序。
2 1 4 3 5 6 5 7 8 9
==============>
1 2 3 4 5 5 6 7 8 9

核心代码：
int a[] = {9,1,2,5,7,4,8,6,3,5};
int i = 0,j = 0,k = 0,temp = 0;
int len = sizeof(a)/sizeof(a[0]);

for(k = len / 2;k >= 1;k = k / 2) //分成的组数
{
		for(i = k;i < len;i++ )//插入排序的次数   9 , 4  1,8
		{		
				temp = a[i];
				for(j = i - k;j >=0 && a[j] > temp ;j = j - k)//找到每组中的元素，进行排列。
				{																							//每组元素相隔k个
							a[j + k] = a[j];
				}
				a[j + k] = temp;

		}
}
2 ^ x = n===> x = long2 n
在最好的情况下（元素已经排好顺序）：那么只需要循环 n-1  次就可以了，时间复杂度 O（n）
在最差的情况下 （元素是逆序的）：要循环调整次数： [ n * (n-1) ] / 2 ，
时间复杂度为 O（n ^ 2），平均时间复杂度为：O（n ^ 2）