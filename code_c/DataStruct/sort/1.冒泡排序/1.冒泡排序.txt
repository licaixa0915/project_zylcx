冒泡排序：
思路：假如我们要从小到大排序，从第一个值开始，依次和后面的数据比较，
			若是把后面的数据大的话，则交换两个数的位置。再拿第二个数和第三个
			数来比较，若是第二个数比第三个数大的话，则依次比较。依次类推，
			第一个把最大数存放到了最后面。
			下一次依次如此，每次比较完成之后，需要的比较的数就减少一个，因为
			每次最大的数都放到后面了，不需要比较了。

以int a[5] = {5,4,3,2,1}为例来讲解

<1>i = 0,i < 4,j < 4
       j = 0 ,a[0] 与a[1]比较，a[0] > a[1] ，交换
       交换后{4,5,3,2,1}
    	 j = 1 ,a[1] 与a[2]比较，a[1] > a[2] ，交换
       交换后{4,3,5,2,1}
       j = 2 ,a[2] 与a[3]比较，a[2] > a[3] ，交换
       交换后{4,3,2,5,1}
       j = 3,a[3] 与a[4]比较， a[3] > a[4] ，交换
       交换后{4,3,2,1,5}
<2>i = 1,i < 4,j < 3
			 j = 0 ,a[0] 与a[1]比较，a[0] > a[1] ，交换
       交换后{3,4,2,1,5}
    	 j = 1 ,a[1] 与a[2]比较，a[1] > a[2] ，交换
       交换后{3,2,4,1,5}
       j = 2 ,a[2] 与a[3]比较，a[2] > a[3] ，交换
       交换后{3,2,1,4,5}
<2>i = 2,i < 4,j < 2
			 j = 0 ,a[0] 与a[1]比较，a[0] > a[1] ，交换
       交换后{2,3,1,4,5}
    	 j = 1 ,a[1] 与a[2]比较，a[1] > a[2] ，交换
       交换后{2,1,3,4,5}
<2>i = 3,i < 4,j < 1    
       j = 0 ,a[0] 与a[1]比较，a[0] > a[1] ，交换
       交换后{1,2,3,4,5}
       
 冒泡排序的思路：比如有5个数字 ， 5 4 3 2 1
			第一轮后         第二轮后      第三轮后      第四轮后
	 | 5 |		 | 4 |		  | 3 |		| 2 |	      | 1 |
	 | 4 |		 | 3 |		  | 2 |		| 1 |	      | 2 |
	 | 3 |----->	 | 2 |----------> | 1 |-------> | 3 |------>  | 3 |
	 | 2 |           | 1 |	      	  | 4 |	        | 4 |	      | 4 |
	 | 1 |  	 | 5 |		  | 5 |		| 5 |	      | 5 |
	 原始      
          交换4次          交换3次          交换2次      交换1次       
       
核心代码：
int a[5] = {5,4,3,2,1}
int i = 0,j = 0;
int n = sizeof(a) / sizeof(a[0]);

for(i = 0;i < n - 1;i++)  		// 运行O(n)次
{  
		for(j = 0;j < n - 1 - i;j++)	
		{
				if(a[j] > a[j + 1])
				{
						a[j] ^= a[j + 1];
						a[j + 1] ^= a[j];
						a[j] ^= a[j + 1];
				}
		}
}
i = 0 ,内存for循环运行n - 1次。
i = 1, 内存for循环运行n - 2次。
i = n - 2,内存for循环运行1次.
频度：1 + 2 + 3+... + n - 1 =n * (n - 1) / 2 ===>时间复杂度为：O(n ^ 2) 
       
       
       
       
       
       
       
       
       